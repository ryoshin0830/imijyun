2025年に向けたExpoとNext.jsのTurborepoモノレポ統合アーキテクチャ設計書序論本ドキュメントは、英語学習Webアプリケーション「Imijun」の技術基盤を次世代へと進化させるための、包括的な技術設計書です。現在のNext.js 14ベースのWebアプリケーションに加え、新たにReact Native/Expoモバイルアプリケーションを導入し、両プラットフォーム間で最大限のコード共有を実現することを戦略的目標とします。この統合は、Turborepoとpnpmで管理される既存のモノレポエコシステム内で行われます。この設計書は、単なる概要説明に留まらず、2025年初頭の技術的ベストプラクティスに基づいた、実践的かつ詳細な実装ブループリントを提供します。プロジェクトのセットアップから、開発ワークフロー、パフォーマンス最適化、そしてTestFlightおよびGoogle Playへの自動デプロイメントパイプラインの構築に至るまで、開発ライフサイクル全体を網羅します。各セクションでは、具体的な設定例、コードスニペット、そして潜在的な技術的課題とその回避策を提示し、開発チームが直面するであろうあらゆる局面に対応可能な、堅牢でスケーラブルな統一開発基盤の構築を目的とします。1. モノレポ基盤のアーキテクチャ設計プロジェクト全体の成功は、堅牢で適切に構成されたモノレポ基盤にかかっています。ここでの設定ミスは、開発ライフサイクル全体にわたり、デバッグが困難な問題として影響を及ぼす可能性があります。本セクションでは、ワークスペース構造を綿密に定義し、pnpmとReact Native間の重大な互換性の問題に対処し、Turborepoを最適なパフォーマンスで構成する方法を詳述します。1.1. Turborepoとpnpmによるワークスペース構成論理的な構成とTurborepoの依存関係グラフ分析のためには、標準的かつ推奨されるディレクトリ構造を採用することが不可欠です。ディレクトリ構造: デプロイ可能なアプリケーション（例: web、mobile）を格納するapps/ディレクトリと、共有コード（例: ui、core-logic、config-typescript）を格納するpackages/ディレクトリに分割します 1。この関心事の分離は、プロジェクトの整理と保守性を高める上で極めて重要です。pnpm Workspaces: モノレポのルートにpnpm-workspace.yamlファイルを作成し、ワークスペースを定義します。これはpnpmがモノレポ内のパッケージを識別するための主要なメカニズムです 1。pnpm-workspace.yaml 設定例:YAMLpackages:
  - 'apps/*'
  - 'packages/*'
ルートpackage.json: ルートのpackage.jsonには"private": trueを設定し、誤った公開を防ぎます。ここには、turbo、typescript、prettierなど、ワークスペース全体で共通のdevDependenciesを配置します 1。また、Turborepoを活用して各ワークスペースのタスクを連携させるためのルートレベルのスクリプト（例: pnpm build, pnpm dev）を定義します。pnpmの使用強制: 開発チーム全体でパッケージマネージャーの一貫性を保つため、ルートのpackage.jsonにpreinstallスクリプトを追加します。only-allowを使用することで、npmやyarnの誤用を防ぎ、環境に起因する問題を未然に防止します 2。package.json スクリプト例:JSON{
  "scripts": {
    "preinstall": "npx only-allow pnpm"
  }
}
1.2. pnpm Hoisting問題の解決：最重要前提条件pnpmとReact Nativeエコシステムを統合する上で、最も重大な障害となるのが依存関係の解決方法の違いです。この問題を正しく理解し、対処することが、プロジェクトの安定性を確保する上での絶対的な前提条件となります。問題の核心: pnpmはデフォルトで、node_modulesを非フラットな構造で管理し、中央のストアへのシンボリックリンクを使用します。このアプローチはディスクスペースの効率化に貢献しますが、React Nativeのツールチェイン（特にMetro Bundlerやネイティブビルドスクリプト）の多くは、伝統的なフラットなnode_modules構造を前提としています。これらのツールは、直接の依存関係として宣言されていないパッケージ（いわゆる「ファントム依存」）にアクセスできることを期待しており、pnpmのデフォルト設定はこの期待を裏切るため、モジュール解決エラーを引き起こします 3。推奨される解決策: この互換性問題を解決するための最も確実かつ広く採用されている方法は、モノレポのルートに.npmrcファイルを作成し、以下の設定を記述することです 3。node-linker=hoisted
この設定は、pnpmに対して、Yarn Classicやnpmと同様のフラットなnode_modules構造を生成するよう指示します。これにより、React Nativeツールとの互換性が確保されます。このアプローチはpnpmの厳格な依存関係分離という利点の一部を犠牲にしますが、React Nativeエコシステムにおける安定性という、より大きな利益をもたらすための必要なアーキテクチャ上の決定です 3。1.3. turbo.jsonによるタスクパイプラインの定義Turborepoの真価は、turbo.jsonファイルでタスク間の依存関係グラフを定義し、キャッシュを賢く利用することにあります。これにより、ビルド時間の大幅な短縮が可能になります 1。パイプライン構成: ルートにturbo.jsonを配置し、build、lint、devなどのタスクの振る舞いを定義します。キャッシュ戦略: buildやlintのようなキャッシュ可能なタスクに対してoutputsプロパティを定義します。例えば、共有UIパッケージのbuildタスクの出力はdist/**、Next.jsアプリケーションの出力は.next/**となります。これにより、入力ファイルに変更がない限りタスクは再実行されず、CI/CDやローカルでのビルドが劇的に高速化されます 2。タスク依存関係: dependsOnプロパティを使用してタスク間の依存関係を明示します。例えば、mobileアプリケーションのbuildタスクは、それが依存する共有パッケージ（uiやcore-logicなど）のbuildタスクが完了している必要があることを"dependsOn": ["^build"]と記述して示します。^プレフィックスは、ワークスペース内の依存関係を意味します 2。開発サーバー (dev): devタスクは長時間実行されるプロセスであるため、"cache": falseと"persistent": trueを設定し、キャッシュの対象外とします 9。turbo.json 設定例:JSON{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
    },
    "lint": {},
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
node-linker=hoistedという設定は、単なる回避策ではなく、アーキテクチャ上の重要なコミットメントです。これは、pnpmの純粋な依存関係分離モデルよりも、React Nativeエコシステムとの互換性を優先するという意図的な選択を意味します。React Nativeのツール群は、フラットなnode_modules構造に暗黙的に依存しており、この構造下では推移的な依存関係にもアクセス可能です。このトレードオフを理解することは、将来の依存関係の問題をデバッグする上で不可欠です。同様に、TurborepoのキャッシュはMetroのキャッシュメカニズムと連携するように慎重に構成する必要があります。最も効率的な構成は、TurborepoがMetro自体のキャッシュの「結果」をキャッシュするという二段構えのシステムです。これには、Expoアプリのbuildスクリプトが、Metroキャッシュを生成するステップ（例: npx expo export）を含み、Turborepoがそのキャッシュディレクトリをoutputsとして指定する、といった工夫が考えられます 4。表1: コアモノレポ設定リファレンスこの表は、プロジェクトの基盤となる設定ファイルの最も重要な項目をまとめたクイックリファレンスです。ファイルキー設定値 / 例目的と根拠pnpm-workspace.yamlpackages- 'apps/*'
- 'packages/*'pnpmにモノレポの構造を定義します。.npmrcnode-linkerhoisted【最重要】 フラットなnode_modulesを生成し、React Nativeツールとの互換性を確保します。turbo.jsonpipeline.build.dependsOn^build依存する共有パッケージがアプリケーションより先にビルドされることを保証します。turbo.jsonpipeline.build.outputs["dist/**", ".next/**"]キャッシュ対象の成果物を定義し、不要な再ビルドを防ぎます。metro.config.jswatchFolders``【重要】 Metroがモノレポ全体のファイル変更を監視できるようにします。metro.config.jsresolver.nodeModulesPaths``【重要】 Metroがルートとアプリ両方のnode_modulesから依存関係を解決できるようにします。metro.config.jsresolver.disableHierarchicalLookuptrue【重要】 Metroの階層的なモジュール検索を無効化し、共有UIライブラリの依存関係解決を安定させます。2. クロスプラットフォームツールチェインの統一モノレポの基盤が固まったところで、次はこの基盤上にExpoアプリケーションを統合します。ここでの中心的な課題は、Metro Bundlerをモノレポ構造に正しく適応させることです。これは、アプリケーションの正常な動作はもちろん、Fast Refresh（高速リフレッシュ）のような開発体験を左右する重要な要素です。2.1. Expoアプリケーションの統合プロジェクトの生成: pnpm create expo-app apps/mobileコマンドをモノレポのルートで実行し、appsディレクトリ内に新しいExpoプロジェクトを直接生成します 10。初期クリーンアップ: React NativeのCLIが生成する可能性のあるネストされた.gitディレクトリは、サブモジュールとしての競合を避けるために削除する必要があります (rm -rf apps/mobile/.git) 11。依存関係のインストール: プロジェクト生成後、モノレポのルートディレクトリからpnpm installを実行し、ワークスペース間のリンクを正しく設定します。2.2. Metro Bundlerのモノレポ対応Metroはデフォルトでは自身のプロジェクトディレクトリしか監視しないため、モノレポ内の共有packages/*フォルダの変更を検知できず、開発プロセスが破綻します。この問題を解決するための設定が不可欠です 8。Expo SDK 52以降の自動設定: expo/metro-configを使用しているExpo SDK 52以降のプロジェクトでは、モノレポが自動的に検出され、必要なMetro設定が適用されます 8。この場合、開発者はmetro.config.jsから手動で設定したwatchFoldersやnodeModulesPathsなどを削除する必要があります。設定を削除した後、npx expo start --clearを実行して古いMetroキャッシュを消去することが重要です 8。手動設定（旧SDKおよびデバッグ目的）: 自動設定の裏側で何が行われているかを理解し、問題発生時にデバッグできるように、手動での設定方法を把握しておくことは極めて有益です。以下は、apps/mobile/metro.config.jsの標準的な手動設定です 7。watchFolders: 共有パッケージの変更を検知するために、モノレポのルートディレクトリを指定する必要があります。resolver.nodeModulesPaths: Hoistされた依存関係を解決するために、apps/mobile/node_modulesとルートのnode_modulesの両方のパスを指定する必要があります。resolver.disableHierarchicalLookup: この設定をtrueにすることで、MetroはnodeModulesPathsで指定されたパスのみを検索するようになります。これにより、Metroがシンボリックリンク構造内で依存関係を解決しようとして混乱するのを防ぎます。これは特に、NativeWindのようなスタイリングライブラリを共有パッケージで使用する際に発生する問題の解決に不可欠です 12。metro.config.js 手動設定例（Pre-SDK 52）:JavaScriptconst { getDefaultConfig } = require('expo/metro-config');
const path = require('path');

// モノレポのルートディレクトリを特定
const workspaceRoot = path.resolve(__dirname, '../..');
const projectRoot = __dirname;

const config = getDefaultConfig(projectRoot);

// 1. モノレポ内のすべてのファイルを監視対象に設定
config.watchFolders =;

// 2. Metroにパッケージを解決する場所と順序を指示
config.resolver.nodeModulesPaths =;

// 3. Metroに（サブ）依存関係を`nodeModulesPaths`からのみ解決させる
config.resolver.disableHierarchicalLookup = true;

module.exports = config;
2.3. シームレスな開発体験の確保：Hot ReloadingとFast RefreshFast Refreshは、コンポーネントの状態を維持したまま、コードの変更を即座にUIに反映させるReact Nativeのコア機能です 14。モノレポ環境でこの機能を安定して動作させることが、生産性の高い開発の鍵となります。モノレポでの落とし穴: Fast RefreshはMetroのファイルウォッチャーに依存しています。前述のmetro.config.jsでwatchFoldersがモノレポのルートに設定されていない場合、共有パッケージ内の変更がリフレッシュをトリガーせず、開発のフィードバックループが機能しなくなります 8。セクション2.2で示した正しいMetro設定が、この問題の根本的な解決策です。トラブルシューティング:Metro設定の確認: metro.config.jsがモノレポのルートを正しく監視していることを再確認します。起動コマンドの統一: 開発サーバーは、必ずモノレポのルートからTurborepo経由で起動します（例: pnpm dev）。個別のアプリディレクトリから直接起動しないでください。キャッシュのクリア: 問題が解決しない場合は、npx expo start --clearでMetroのキャッシュを完全にクリアします 8。依存関係の重複確認: モノレポ内にreactやreact-nativeの複数バージョンが存在すると、Fast Refreshが破損したり、ランタイムエラーが発生したりする可能性があります。pnpm why react-nativeのようなコマンドで重複がないか確認します 8。MetroのdisableHierarchicalLookup設定は、共有UIコンポーネントを安定して利用するための鍵です。これがなければ、共有ロジックは動作しても、NativeWindでスタイル付けされた共有UIコンポーネントが自身の依存関係を解決できず、不可解なエラーを引き起こす可能性があります。この設定は、Metroの予測不可能なファイルシステム探索を止めさせ、nodeModulesPathsで指定されたパスのみに従わせることで、確定的で信頼性の高いモジュール解決環境を構築します。これは、本プロジェクトのコア要件であるUIのコード共有を実現するための必須設定と言えます 12。また、Expo SDK 52以降の「自動設定」は、初期セットアップを簡素化する一方で、その背後にある重要なメカニズムを覆い隠してしまいます。この抽象化は、問題が発生した際に、その根本原因を理解していないチームのデバッグを困難にする可能性があります。したがって、本設計書では、自動設定を推奨しつつも、手動設定の詳細な解説を含めることが重要です。これにより、チームは「魔法」の裏側を理解し、問題解決能力を高めることができます 8。3. 多層的なコード共有戦略Webとモバイルの両プラットフォームで最大限のコードを再利用することは、このプロジェクトの主要目標です。本セクションでは、ビジネスロジック、状態管理、UIコンポーネント、スタイリングといった複数のレイヤーにわたる具体的なコード共有戦略を詳述します。3.1. コアビジネスロジックと型の共有アプリケーションの核となるロジックやデータ型は、プラットフォームに依存しない純粋なTypeScriptで記述し、共有パッケージとして管理します。共有パッケージの作成: packages/coreのような名前で共有パッケージを作成します。ここには、状態管理のロジック（Zustandストアの定義）、APIクライアント、データ型定義、ユーティリティ関数などを配置します。共有tsconfig.json: モノレポ全体でTypeScriptの設定を統一するため、packages/typescript-configのような設定専用パッケージを作成します。このパッケージには、base.json（共通設定）、nextjs.json（Next.js用）、react-native.json（React Native用）といった複数の設定ファイルを含みます。各アプリやパッケージは、自身のtsconfig.jsonでこれらの設定をextendsします 16。packages/typescript-config/base.json 例:JSON{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "resolveJsonModule": true,
    "isolatedModules": true
  }
}
package.jsonのexportsフィールド: 共有パッケージのpackage.jsonでexportsフィールドを適切に設定することは、TypeScriptの型解決とIDEのIntelliSenseを最適化し、開発者体験を向上させる上で非常に重要です。typesフィールドでソースの.tsファイルを、defaultフィールドでコンパイル後の.jsファイルを指定することで、エディタは常に最新の型定義を参照し、パッケージ間の「定義へ移動」もスムーズに機能します 16。packages/core/package.json exports設定例:JSON{
  "name": "@imijun/core",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "default": "./dist/index.js"
    },
    "./*": {
      "types": "./src/*.ts",
      "default": "./dist/*.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  }
}
3.2. クロスプラットフォームの状態管理Zustandは軽量でボイラープレートが少ないため、Next.jsとReact Nativeの両方で共有するのに適した状態管理ライブラリです。ただし、Next.jsのサーバーサイドレンダリング（SSR）環境で正しく動作させるためには、Providerパターンを採用する必要があります。ストアの定義: ストアの作成ロジック (createStore) は共有パッケージ (@imijun/core) に配置します。重要なのは、グローバルなシングルトンインスタンスを作成するのではなく、リクエストごとに新しいストアインスタンスを生成するファクトリ関数をエクスポートすることです 17。Providerパターンの実装: ReactのContext APIを使用して、ストアのインスタンスをコンポーネントツリーに提供するStoreProviderコンポーネントを作成します。このProviderは、'use client'ディレクティブを持つクライアントコンポーネントとして実装する必要があります。これにより、サーバーリクエスト間で状態が共有されるのを防ぎ、ハイドレーションエラーを回避します 17。Next.jsでの利用: app/layout.tsxや各ページのルートでStoreProviderをラップし、サーバーコンポーネントから渡された初期状態をストアに注入します。Expoでの利用: アプリケーションのエントリーポイント（例: app/_layout.tsx）でStoreProviderをラップします。このパターンにより、同じZustandストアの定義をWebとモバイルで共有しつつ、各プラットフォームのレンダリング特性（特にNext.jsのSSR）に適切に対応できます 17。3.3. NativeWindとTailwind CSSによる統一されたスタイリングNativeWindは、React Native上でTailwind CSSのユーティリティクラス構文を使用可能にするライブラリです。これを活用し、Webとモバイルで一貫したデザイントークンとスタイリング体験を実現します。設定の集約: tailwind.config.jsをモノレポのルートに配置し、両方のアプリケーションがこれを共有するようにします。contentフィールドには、appsとpackages内のすべてのコンポーネントファイルへのパスを含める必要があります 13。ルート tailwind.config.js content設定例:JavaScriptmodule.exports = {
  content: [
    "./apps/web/app/**/*.{js,ts,jsx,tsx}",
    "./apps/mobile/app/**/*.{js,ts,jsx,tsx}",
    "./packages/ui/src/**/*.{js,ts,jsx,tsx}",
  ],
  //... a shared theme
};
Expo (NativeWind) の設定:metro.config.js: withNativeWind HOC (Higher-Order Component) でMetroの設定をラップします。これにより、NativeWindが必要な変換を適用できるようになります 20。babel.config.js: nativewind/babelプリセットを追加します 20。グローバルCSS: global.cssファイルを作成し、@tailwindディレクティブを記述し、アプリのエントリーポイントでインポートします 21。Next.js (Tailwind CSS) の設定:postcss.config.js: 標準的なTailwind CSSのPostCSSプラグインを設定します。next.config.js: transpilePackagesオプションにnativewindとreact-native-css-interopを追加し、これらのパッケージがNext.jsによって正しくトランスパイルされるようにします 22。この構成により、共有UIパッケージ内で定義されたコンポーネントが、Webでは標準的なCSSクラスとして、モバイルではStyleSheetオブジェクトとして正しく解釈され、一貫した見た目を保つことができます 23。3.4. プラットフォーム固有のコンポーネントアーキテクチャすべてのUIが完全に共有可能であるとは限りません。プラットフォーム固有の実装が必要な場合は、ファイル拡張子を利用した分離戦略が有効です。ファイル拡張子の使い分け: React Nativeのバンドラー (Metro) とWebのバンドラー (Next.js/Webpack) は、特定の拡張子を持つファイルを優先的に解決する機能を持っています。Component.native.tsx: iOSとAndroidの両方で読み込まれます。Component.web.tsx: Next.js (Web) で読み込まれます。Component.ios.tsx: iOSでのみ読み込まれます。Component.android.tsx: Androidでのみ読み込まれます。インポートする際は、拡張子を省略してimport Component from './Component'と記述します。バンドラーが実行環境に応じて適切なファイルを自動的に選択します 24。ベストプラクティス:ロジックの共通化: 可能な限りロジックはカスタムフック (useComponentLogic.ts) に抽出し、UI部分のみをプラットフォーム固有ファイル (index.native.tsx, index.web.tsx) に分離します。小さな差異: スタイルシートのプロパティなど、ごくわずかな違いの場合は、Platform.select APIを使用する方が簡潔です 24。大きな差異: レンダリングするコンポーネントが根本的に異なる場合（例: Webでは<div>、Nativeでは<View>）、ファイル拡張子による分離が最適です 24。この多層的なアプローチにより、最大限のコード共有を達成しつつ、各プラットフォームの特性を活かした最適なユーザー体験を提供するための柔軟性を確保します。4. 機能実装ケーススタディ：「Imijun」ドラッグ＆ドロップインターフェースこのセクションでは、プロジェクトのコア機能である「意味順」のドラッグ＆ドロップインターフェースを、Webからモバイルへ移行するための具体的な戦略と実装方法を解説します。Webで実績のある@dnd-kitから、React Nativeのネイティブなジェスチャーシステムを活用したライブラリへの移行が焦点となります。4.1. 最適なネイティブドラッグ＆ドロップライブラリの選定@dnd-kitはWeb向けに高度に最適化されており、その柔軟性とパフォーマンスをReact Nativeで再現することが目標です。react-native-gesture-handlerとreact-native-reanimatedを基盤とするモダンなライブラリが最良の選択肢となります。比較分析:react-native-draggable-flatlist: リスト内での並べ替えに特化しており、非常に高性能で広く使われています。しかし、リスト間でのアイテム移動や、リスト外の固定ドロップゾーンへのドロップといった、より複雑なユースケースには直接対応していません 26。react-native-reanimated-dnd: @dnd-kitに強くインスパイアされており、DraggableやDroppableといった低レベルなプリミティブを提供します。これにより、リスト、グリッド、複数のドロップゾーンを持つカスタムレイアウトなど、非常に柔軟なインタラクションを構築できます。衝突検出アルゴリズムやドラッグハンドルのサポートなど、高度な機能も備えています 28。@mgcrea/react-native-dnd: こちらも@dnd-kitにインスパイアされたフックベースのライブラリで、useDraggableとuseDroppableを提供し、高いパフォーマンスと柔軟性を両立しています 30。推奨ライブラリ: 「Imijun」の要件である「5つの固定ドロップゾーン」と「ドラッグ可能な単語ボックス」という構成には、@dnd-kitと同様のプリミティブベースのアプローチが最も適しています。そのため、react-native-reanimated-dnd または @mgcrea/react-native-dnd の採用を強く推奨します。これらのライブラリは、@dnd-kitの宣言的なAPI設計思想を継承しており、Webからの移行をスムーズにします 29。4.2. 複数ドロップゾーンを持つ文構築UIの実装react-native-reanimated-dndを例に、具体的な実装アプローチを解説します。コンポーネント構造:DropProvider: ドラッグ＆ドロップのコンテキストを提供するため、UI全体をこのコンポーネントでラップします 28。Droppableコンポーネント: 5つの「意味順ボックス」（主語、動詞など）をそれぞれDroppableコンポーネントで実装します。各Droppableには一意のidを割り当てます。onDropコールバックで、アイテムがドロップされた際のロジックを処理します 28。Draggableコンポーネント: ユーザーがドラッグする各単語ボックスをDraggableコンポーネントで実装します。dataプロパティに、単語の情報（ID、テキストなど）を含めます。状態管理:ドラッグ可能な単語のリスト（ソース）と、各ドロップゾーンの状態（ターゲット）をReactのuseStateや、より複雑な場合はZustandストアで管理します。handleDrop関数は、onDropイベントから渡されるdata（ドラッグされたアイテムの情報）とzoneId（ドロップされたゾーンのID）を受け取ります。この関数内で、ソースリストからアイテムを削除し、対応するターゲットゾーンのリストにアイテムを追加する状態更新ロジックを実装します。実装コードの概念例 (react-native-reanimated-dndを使用):TypeScriptimport React, { useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { Draggable, Droppable, DropProvider } from 'react-native-reanimated-dnd';

const WORD_BANK = [{ id: 'word-1', text: 'I' }, { id: 'word-2', text: 'learn' }];
const DROP_ZONES = ['subject', 'verb', 'object', 'complement', 'modifier'];

export default function ImijunSentenceBuilder() {
  const = useState(WORD_BANK);
  const = useState(
    DROP_ZONES.reduce((acc, zone) => ({...acc, [zone]: null }), {})
  );

  const handleDrop = (data, zoneId) => {
    console.log(`"${data.text}" dropped in ${zoneId}`);

    // 状態更新ロジック
    setSentence(prev => ({...prev, [zoneId]: data }));
    setWordBank(prev => prev.filter(word => word.id!== data.id));
  };

  return (
    <GestureHandlerRootView style={styles.container}>
      <DropProvider>
        {/* ドロップゾーン */}
        <View style={styles.sentenceContainer}>
          {DROP_ZONES.map(zoneId => (
            <Droppable
              key={zoneId}
              onDrop={(data) => handleDrop(data, zoneId)}
              style={styles.dropZone}
              activeStyle={styles.dropZoneActive}
            >
              <View style={styles.dropZoneInner}>
                {sentence[zoneId]? (
                  <Text>{sentence[zoneId].text}</Text>
                ) : (
                  <Text style={styles.placeholder}>{zoneId}</Text>
                )}
              </View>
            </Droppable>
          ))}
        </View>

        {/* ドラッグ可能な単語 */}
        <View style={styles.wordBankContainer}>
          {wordBank.map(word => (
            <Draggable key={word.id} data={word}>
              <View style={styles.draggableItem}>
                <Text style={styles.draggableText}>{word.text}</Text>
              </View>
            </Draggable>
          ))}
        </View>
      </DropProvider>
    </GestureHandlerRootView>
  );
}

// スタイルシート定義 (省略)
const styles = StyleSheet.create({ /*... */ });
この実装により、Web版の@dnd-kitが提供する柔軟なドラッグ＆ドロップ体験を、React Nativeのネイティブパフォーマンスを活かしてモバイル上で忠実に再現することが可能になります 28。5. モダンな開発と本番ワークフロー効率的な開発サイクルと高品質なアプリケーションの提供には、目的に応じたツールとワークフローの選択が不可欠です。本セクションでは、初期開発から本番ビルドまでのプロセスを定義し、将来の技術的負債を回避するためのパフォーマンス最適化戦略について論じます。5.1. 開発ワークフロー：Expo GoからDevelopment BuildへExpoは、開発のフェーズに応じて最適なツールを提供しています。これらを適切に使い分けることが重要です。フェーズ1: Expo Goによる初期開発・プロトタイピング目的: Expo Goは、ネイティブコードを含まない純粋なJavaScript/TypeScriptのロジックやUIコンポーネントを迅速に確認するためのサンドボックス環境です 33。利点: Android StudioやXcodeのセットアップが不要で、QRコードをスキャンするだけで実機でのテストが開始できるため、立ち上がりが非常に速い 34。タイミング: プロジェクトの初期段階、UIのレイアウト確認、共有ロジックの単体テストなどに最適です。フェーズ2: Development Buildへの移行移行のトリガー: 以下のいずれかの要件が発生した時点で、Expo GoからDevelopment Buildに移行する必要があります。Expo Goに含まれていないカスタムネイティブモジュールを使用する場合（例: react-native-firebase）33。アプリのアイコン、スプラッシュスクリーン、バンドルIDなど、ネイティブ側の設定をカスタマイズしてテストする必要がある場合 33。プッシュ通知、ディープリンク、OAuth認証など、サンドボックス環境では正確なテストが困難な機能を実装する場合 34。Development Buildとは: expo-dev-clientライブラリを含む、あなた自身のアプリのデバッグビルドです。これは、あなたのプロジェクト専用にカスタマイズされたExpo Goと考えることができます 36。利点: ネイティブランタイムを完全に制御でき、あらゆるネイティブライブラリの追加やネイティブコードの変更が可能です。これにより、開発環境と本番環境の差異が最小限に抑えられ、より信頼性の高いテストが可能になります 36。セットアップ: npx expo install expo-dev-clientを実行し、npx expo run:androidまたはnpx expo run:iosでローカルビルドを生成・インストールします 36。フェーズ3: EAS Buildによるクラウドビルド目的: EAS (Expo Application Services) Buildは、ローカルマシンにXcodeやAndroid Studioをセットアップすることなく、クラウド上でアプリケーションのバイナリ（.apk,.aab,.ipa）を生成するサービスです 36。タイミング: チーム内でのテストビルド配布、TestFlightやGoogle Play内部テストへの提出、そして最終的な本番リリースビルドの作成時に使用します。CI/CDパイプラインとの統合にも不可欠です。利点: ビルド環境の差異をなくし、証明書の管理などを自動化することで、ビルドプロセスを大幅に簡素化・高速化します 36。2025年時点のベストプラクティスとして、**「実用的なアプリ開発では、可能な限り早期にDevelopment Buildへ移行する」**ことが推奨されます。Expo Goはあくまで学習や実験のためのツールであり、本番に近い環境での開発が品質を保証する鍵となります 34。5.2. パフォーマンス最適化と将来性確保アプリケーションの応答性と将来の拡張性を担保するため、アーキテクチャと実行エンジンの選定は慎重に行う必要があります。5.2.1. 意思決定フレームワーク：New Architectureの採用React NativeのNew Architecture（Fabric RendererとTurboModules）は、パフォーマンスを向上させるための将来的な基盤ですが、その採用はトレードオフを伴います 39。利点:JSI (JavaScript Interface) により、従来のブリッジを介した非同期通信が同期的な直接呼び出しに置き換わり、ネイティブ連携のオーバーヘッドが大幅に削減されます 39。Concurrent Reactの機能（Suspense、Transitionsなど）を完全にサポートし、よりスムーズで応答性の高いUIを実現できます 41。Shopifyなどの事例では、アプリの起動時間が改善し、不要な再レンダリングが減少したと報告されています 43。採用の判断基準: 2025年後半にはレガシーアーキテクチャが廃止される可能性があるため、新規プロジェクトでは採用が強く推奨されます 40。採用を決定する前に、以下のチェックリストでプロジェクトの準備状況を評価する必要があります。表2: New Architecture採用意思決定マトリクス評価項目採用を後押しする条件採用に慎重になるべき条件備考依存ライブラリの互換性主要な依存ライブラリがすべてNew Architectureに対応済みである。未対応の重要なライブラリが存在する。expo-doctorやReact Native Directoryで互換性を確認できます 40。パフォーマンス要件高度なアニメーション、リアルタイムデータ処理、UIの同期的なレイアウト計算が必須である。アプリケーションが主に静的なコンテンツ表示や基本的なフォーム操作で構成されている。New Architectureの恩恵は、パフォーマンスがボトルネックとなる箇所で最も顕著です 41。チームの習熟度チームがC++やネイティブモジュールのデバッグに一定の知識を持っている、または学習意欲が高い。チームが主にJavaScript/TypeScriptに特化しており、ネイティブレイヤーのデバッグ経験が乏しい。TurboModuleのデバッグは、従来のネイティブモジュールとは異なるスキルセットを要求する場合があります 43。将来性への投資長期的にメンテナンスされるプロダクトであり、将来のReact Nativeの新機能を活用したい。短期的なプロジェクトやプロトタイプである。将来のアップグレードコストを考慮すると、早期採用が有利です 40。結論: Expo SDK 52以降、新規プロジェクトはデフォルトでNew Architectureが有効になります 40。依存ライブラリの互換性に問題がない限り、このデフォルト設定に従うことが最も将来性のある選択です。5.2.2. JavaScriptエンジン分析：Hermes vs JSCReact NativeはデフォルトでHermesエンジンを使用しており、ほとんどのユースケースで最適な選択肢です 44。Hermes:特徴: Ahead-of-Time (AOT) コンパイルを採用しており、アプリのビルド時にJavaScriptをバイトコードに事前コンパイルします 45。利点: これにより、アプリの起動時間（T T I: Time To Interactive）が大幅に短縮され、メモリ使用量とアプリサイズも削減される傾向にあります 44。適した用途: 一般的なコンシューマー向けアプリケーション、起動速度が重視されるアプリ。JavaScriptCore (JSC):特徴: Just-in-Time (JIT) コンパイルを採用しており、実行時にコードを最適化します 47。利点: 長時間実行される純粋な計算処理（例: 大規模なデータ操作）では、JITによる最適化が効いてHermesよりも高速になる場合があります 47。適した用途: 計算集約型の特殊な処理がアプリのボトルネックとなっている場合。2025年時点での推奨:React Nativeのデフォルトであり、Metaとコミュニティによる継続的な最適化が進んでいるHermesを引き続き使用することを強く推奨します。起動時間の改善というユーザー体験に直結するメリットは、ほとんどのアプリケーションにとって、JSCが持つ特定の計算処理における速度的優位性を上回ります 45。もし特定の処理でパフォーマンス問題が発生した場合は、その部分だけをネイティブモジュール化する方が、エンジン全体をJSCに戻すよりも効果的な解決策となります。6. ビルドとデプロイメントパイプラインの自動化手動でのビルドとデプロイは、ヒューマンエラーの温床となり、開発サイクルのボトルネックとなります。GitHub Actions、Turborepo、EASを連携させることで、コードのマージからテスターへの配布までを完全に自動化し、迅速かつ信頼性の高いリリースプロセスを構築します。6.1. GitHub ActionsとEAS BuildによるCI/CDこのワークフローは、mainブランチへのプッシュをトリガーとして、Expoアプリケーションのビルドを自動的に開始します。ワークフローの主要ステップ:リポジトリのチェックアウト: actions/checkout@v4を使用します。Node.jsとpnpmのセットアップ: actions/setup-node@v4とpnpm/action-setup@v3を使用し、pnpm-lock.yamlに基づいたキャッシュを有効にします 9。Turborepoキャッシュの復元: actions/cache@v4を使用して、以前の実行で保存された.turboディレクトリを復元します。これにより、変更のないパッケージのビルドがスキップされます 9。Expo/EAS CLIのセットアップ: expo/expo-github-action@v8を使用します。このアクションは、EAS CLIのインストールと、EXPO_TOKENシークレットを使用したExpoアカウントへの認証を自動的に行います 49。依存関係のインストール: pnpm installを実行します。EAS Buildの実行: eas buildコマンドを--non-interactiveフラグ付きで実行します。このコマンドはビルドをEASのクラウドキューに投入し、即座に終了するため、GitHub Actionsの実行時間を消費しません 49。Turborepoキャッシュ戦略:GitHub Actionsのcacheアクションは、Turborepoのリモートキャッシュとは異なる、ファイルベースのキャッシュです。.turboディレクトリをキャッシュキー（例: runner.os, git sha）と関連付けて保存・復元します 9。より高度な設定として、Vercelが提供するTurborepoのリモートキャッシュを利用することも可能です。これにはTURBO_TOKENとTURBO_TEAMの環境変数を設定する必要がありますが、チーム全体でキャッシュを共有できるため、さらなる高速化が期待できます 9。GitHub Actions ワークフロー設定例:YAMLname: Build Expo App

on:
  push:
    branches:
      - main

jobs:
  build:
    name: EAS Build
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 8

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Set up Expo and EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Install dependencies
        run: pnpm install

      - name: Pre-build shared packages
        # EASはコミットされたファイルのみを送信するため、
        # 共有パッケージのビルド成果物 (dist) を生成する必要がある
        run: pnpm build --filter=!mobile --filter=!web

      - name: Trigger EAS Build
        # EASはモノレポのルートからすべてのファイルをtarball化するが、
        # ビルドコマンドはアプリのディレクトリ内で実行する必要がある
        run: cd apps/mobile && eas build --platform all --profile production --non-interactive
注意点: EAS Buildは、実行されたディレクトリを基準に動作しますが、モノレポのルートからすべてのファイルをtarballとしてアップロードします。そのため、ビルドコマンドはアプリのディレクトリ (apps/mobile) 内で実行する必要があります 4。また、EASはコミットされていないファイルをビルドに含めないため、共有パッケージのビルド成果物（例: packages/ui/dist）を生成するステップがCI上で必要になる場合があります 4。6.2. TestFlightとGoogle Play内部テストへの自動デプロイビルドが成功した後、その成果物をテスターに自動的に配布することで、フィードバックサイクルを加速させます。EAS Submitを利用することで、このプロセスも自動化できます。EAS Submit: このコマンドは、ビルドされたバイナリをApp Store ConnectやGoogle Play Consoleにアップロードし、指定されたトラック（例: TestFlightの内部テスト、Google Playの内部テスト）に提出するプロセスを自動化します 51。ワークフローの拡張:ビルドの完了を待機: eas buildを--no-waitなしで実行するか、eas build:listコマンドをポーリングしてビルドの完了を待つロジックを追加します。EAS Submitの実行: ビルドが成功したら、eas submitコマンドを実行します。プラットフォーム（iOS/Android）と提出先のビルドIDまたは--latestフラグを指定します。iOS (TestFlight): eas submit -p ios --latestAndroid (Internal Testing): eas submit -p android --latest --track internal完全自動化ワークフローの概念:YAML#... (前述のビルドジョブ)...

submit:
  name: Submit to Test Stores
  runs-on: ubuntu-latest
  needs: build # ビルドジョブの成功に依存
  steps:
    #... (Setup steps for Node, pnpm, EAS CLI)...

    - name: Submit to TestFlight and Google Play
      run: |
        cd apps/mobile
        eas submit -p ios --profile production --latest --non-interactive
        eas submit -p android --profile production --latest --track internal --non-interactive
認証情報: eas submitをCI環境で実行するには、Apple DeveloperアカウントのApp Store Connect APIキーや、Google PlayのサービスアカウントキーをGitHubのシークレットとして安全に設定する必要があります 49。EASはこれらの認証情報を管理する仕組みを提供しています。このCI/CDパイプラインを構築することで、「Imijun」プロジェクトは、コードのコミットからテスターへの配信までの一連のプロセスを、信頼性高く、かつ迅速に実行できるようになります。7. 高度な考慮事項と戦略的選択モノレポの基盤とCI/CDパイプラインが整った上で、アプリケーションのアーキテクチャをさらに洗練させるためのいくつかの重要な選択肢が存在します。これらの選択は、開発体験、アプリケーションの構造、そして将来の拡張性に直接影響を与えます。7.1. ナビゲーション：Expo Router v3 vs React Navigationナビゲーションライブラリの選択は、アプリケーションの構造と開発パラダイムを決定づける重要な要素です。関係性: Expo Routerは、React Navigationの堅牢な基盤の上に構築された、より意見の強い（opinionated）フレームワークです。競合するライブラリではなく、異なるAPIと開発体験を提供するレイヤーと考えるべきです 52。Expo Router v3:特徴: Next.jsのApp Routerと同様の、ファイルシステムベースのルーティングを採用しています。appディレクトリ内に作成したファイルやフォルダが、自動的にアプリケーションのルート（画面）になります 53。利点:宣言的な構造: ルーティング構造がファイルシステムと一致するため、直感的で予測可能です 52。ボイラープレートの削減: ルートを手動で登録する必要がなく、設定コードが大幅に削減されます。Webとの親和性: 既存のNext.js App Routerに慣れている開発チームにとって、学習コストが低く、Webとモバイルで一貫したメンタルモデルを維持できます 54。ディープリンクの自動化: すべての画面が自動的にディープリンク可能になります 53。考慮点: 比較的新しいライブラリであり、非常に複雑な動的ナビゲーション（サーバーからのデータに基づいてナビゲーター全体を動的に構築するなど）を実装する際には、React NavigationのAPIを直接利用する必要が出てくる場合があります 55。React Navigation:特徴: JavaScriptのコード内でナビゲーター（Stack, Tabsなど）を明示的に設定し、スクリーンを登録するプログラム的なアプローチです 52。利点:最大限の柔軟性: ナビゲーションのあらゆる側面をコードで完全に制御できます。成熟度: 長年の実績があり、あらゆるエッジケースに対応するドキュメントやコミュニティの知見が豊富です。考慮点: アプリケーションが大規模になると、設定ファイルが複雑化し、見通しが悪くなる可能性があります 52。戦略的推奨:Expo Router v3の採用を強く推奨します。その理由は、プロジェクトがすでにNext.js 14のApp Routerを基盤としているためです。ファイルシステムベースのルーティングという共通のパラダイムを採用することで、Webとモバイルの開発チーム間で知識と経験を共有でき、コンテキストスイッチのコストを最小限に抑えることができます。これは、コード共有の最大化というプロジェクトの根本的な目標と完全に一致しています。7.2. React Native 0.74+におけるTypeScript設定のベストプラクティスモノレポ環境におけるTypeScriptの設定は、型安全性を確保し、開発者体験を向上させるために極めて重要です。共有設定の継承: セクション3.1で述べたように、@repo/typescript-configのような共有パッケージを作成し、各ワークスペース（Next.js, Expo, 共有ライブラリ）のtsconfig.jsonで基本設定をextendsするのがベストプラクティスです 16。React Native向けの設定: React Nativeプロジェクトのtsconfig.jsonは、@react-native/typescript-configをextendsすることを基本とします。これにより、React Nativeに必要なデフォルト設定が適用されます 57。JSON// apps/mobile/tsconfig.json
{
  "extends": "@react-native/typescript-config",
  "compilerOptions": {
    "strict": true,
    // プロジェクト固有のパスエイリアスなどをここに追加
  }
}
型の整理:中央集権的な型定義: アプリケーション全体で共有される型（例: APIのレスポンス型、ユーザーモデルなど）は、packages/core/src/typesのような専用のディレクトリにまとめます 56。コンポーネント固有の型: コンポーネントのpropsの型定義は、そのコンポーネントファイルと同じ場所に配置するのが一般的です。React.FC<Props>のようなジェネリクスを使用して、コンポーネントに型を適用します 58。interface vs type: オブジェクトやクラスの構造を定義する場合はinterfaceを、ユニオン型や交差型など、より複雑な型を定義する場合はtypeを使用するという使い分けが推奨されます 59。厳格な設定の有効化: tsconfig.jsonで"strict": true（または"strictNullChecks": trueなど個別の設定）を有効にすることは、予期せぬnullやundefinedによるランタイムエラーを防ぎ、コードの堅牢性を高めるために不可欠です 58。7.3. モノレポでのExpo Modulesプラグイン開発の可能性Expo Modulesは、Swift/Kotlin/C++でネイティブ機能を記述し、それをTypeScriptから簡単に呼び出せるようにする最新のAPIです。モノレポ内で独自のネイティブモジュールを開発することは、プラットフォーム固有の機能をカプセル化し、再利用可能なパッケージとして管理する上で非常に強力なアプローチです。開発プロセス:モジュールの作成: packagesディレクトリ内に、npx create-expo-moduleコマンドを使用して新しいモジュールパッケージを作成します 61。ネイティブコードの実装: 生成されたテンプレート内に、プラットフォーム固有のコード（例: iOSの場合は.swiftファイル、Androidの場合は.ktファイル）を記述します。ワークスペース依存関係の追加: 作成したモジュールを、apps/mobileのpackage.jsonに"workspace:*"プロトコルを使用して依存関係として追加します 61。ビルドと利用: モノレポのルートでpnpm installを実行した後、apps/mobileでnpx expo prebuild --cleanを実行してネイティブプロジェクトを再生成し、モジュールをリンクさせます。その後は、通常のTypeScriptモジュールとしてインポートして使用できます 61。利点:カプセル化: カメラの高度な制御や、特殊なバックグラウンド処理など、特定のネイティブ機能を独立したパッケージとして開発・管理できます。再利用性: このモジュールは、将来的に他のExpoプロジェクトでも再利用可能です。テストの容易性: モジュールが独立しているため、単体テストがしやすくなります。このアプローチにより、「Imijun」プロジェクトは、Expoの提供する豊富なAPIセットを超えて、必要に応じてネイティブの力を最大限に引き出し、独自の機能をシームレスに統合することが可能になります。結論と段階的移行の推奨ステップ本設計書では、Next.js 14ベースのWebアプリケーションとReact Native/Expoモバイルアプリケーションを、Turborepo/pnpmモノレポ内で統合するための包括的な技術的ブループリントを提示しました。コード共有の最大化、開発体験の最適化、そして将来のスケーラビリティ確保を目的とし、2025年初頭のベストプラクティスに基づいた具体的なアーキテクチャと実装戦略を詳述しました。主要なアーキテクチャ推奨事項の要約モノレポ基盤: pnpm workspacesとTurborepoを中核とし、apps/とpackages/のディレクトリ構造を採用します。React Nativeとの互換性を確保するため、.npmrcにnode-linker=hoistedを設定することが最も重要な前提条件です。ツールチェイン: Metro Bundlerは、Expo SDK 52以降の自動設定を活用しつつ、その内部動作（watchFolders, disableHierarchicalLookupなど）を理解しておくことで、デバッグ能力を向上させます。コード共有: ビジネスロジックと型定義は共有TypeScriptパッケージに集約します。状態管理にはZustandをProviderパターンで、スタイリングにはNativeWindとTailwind CSSを共有設定で用いることで、プラットフォーム間で一貫した開発を実現します。UIの差異は、プラットフォーム固有のファイル拡張子（.native.tsx, .web.tsx）で吸収します。開発ワークフロー: 初期段階ではExpo Goを活用し、カスタムネイティブコードが必要になった時点で速やかにDevelopment Buildへ移行します。最終的なビルドと配布はEAS BuildとEAS SubmitをCI/CDパイプラインに組み込んで自動化します。パフォーマンス: New Architectureは、依存ライブラリの互換性を確認した上で、デフォルトで有効化された状態でプロジェクトを開始することを推奨します。JavaScriptエンジンは、起動速度とエコシステムの成熟度からHermesが最適です。ナビゲーション: 既存のNext.js App Routerとの親和性が高いExpo Router v3を採用し、Webとモバイルで一貫したルーティングパラダイムを維持します。段階的移行の推奨ステップこの大規模なアーキテクチャ統合を成功させるためには、段階的かつ計画的なアプローチが不可欠です。以下に推奨する実装ロードマップを示します。フェーズ 1: 基盤構築と環境設定 (1-2週間)モノレポ構成の確定: pnpm-workspace.yamlとルートのpackage.jsonを確定し、.npmrcにnode-linker=hoistedを設定します。Turborepoパイプラインの定義: turbo.jsonで基本的なbuild, dev, lintタスクを定義します。Expoアプリの追加: apps/mobileとしてExpoプロジェクトを生成し、モノレポに統合します。Metro Bundlerの設定: metro.config.jsを設定し、共有パッケージからのインポートとFast Refreshが正常に動作することを確認します。Hello Worldの実現: 共有パッケージ（例: packages/ui）に単純なコンポーネントを作成し、それをNext.jsとExpoの両方で表示できることを確認します。フェーズ 2: コード共有戦略の実装 (2-4週間)共有パッケージの設計: @imijun/core（ロジック、型、Zustandストア）、@imijun/ui（UIコンポーネント）の構造を設計し、実装を開始します。スタイリングの統一: NativeWindとTailwind CSSの共有設定を完了させ、@imijun/ui内のコンポーネントが両プラットフォームで一貫したスタイルで表示されることを確認します。状態管理の統合: ZustandストアをProviderパターンで実装し、Webとモバイルで状態が共有（または同期）できることを検証します。プラットフォーム固有コンポーネントの作成: プラットフォーム固有のファイル拡張子（.native.tsx, .web.tsx）を利用したコンポーネント抽象化のパターンを確立します。フェーズ 3: 機能実装とワークフローの確立 (4-6週間)コア機能の実装: ドラッグ＆ドロップ機能（react-native-reanimated-dnd等）を含む、主要な画面と機能をモバイルアプリに実装します。Development Buildへの移行: 開発ワークフローをExpo GoからDevelopment Buildに完全に移行し、チーム全員が同じ開発環境を共有できるようにします。CI/CDパイプラインの構築: GitHub Actions上でEAS Buildをトリガーする基本的なCIワークフローを構築します。初期テスト配布: ビルドされたアプリを、手動でTestFlightとGoogle Play内部テストにアップロードし、配布プロセスを確認します。フェーズ 4: 最適化と自動化の洗練 (2-3週間)パフォーマンスプロファイリング: アプリのパフォーマンスを測定し、ボトルネックを特定します。必要に応じてReact.memoやuseCallbackの適用、バンドルサイズの分析などを行います。New Architectureの検証: 依存関係の互換性を最終確認し、New Architecture下での動作に問題がないことを保証します。デプロイメントの完全自動化: CIワークフローを拡張し、eas submitを組み込むことで、TestFlightとGoogle Playへの提出を完全に自動化します。ドキュメントの整備: モノレポの構造、共有パッケージの使用方法、CI/CDの運用方法などを文書化し、将来のメンテナンスに備えます。このロードマップに従うことで、「Imijun」プロジェクトは、リスクを管理しつつ、着実にWebとモバイルの技術的統合を達成し、より効率的でスケーラブルな開発基盤を構築することができるでしょう。